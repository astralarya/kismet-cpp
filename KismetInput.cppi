// KismetInput.cppi
// Mara Kim
//
// An interactive prompt for KismetScanner


KismetScannerBase::Input::Input():
d_in(0),
d_lineNr(1) {
}

KismetScannerBase::Input::Input(std::istream *iStream, size_t lineNr):
d_in(iStream),
d_lineNr(lineNr) {
}


size_t KismetScannerBase::Input::get() {
    // get the next input char
    switch (size_t ch = next()) {
    case '\n':
        ++d_lineNr;
    default:
        return ch;
    }
}

size_t KismetScannerBase::Input::next() {
    size_t ch;

    if(d_deque.empty()) {
        // deque empty: next char fm d_in
        if(d_in == 0)
            return AT_EOF;
        if(Options::Instance()->get(INTERACTIVE)) {
            if(::Prompt::eof())
                return AT_EOF;
            // readline prompt
            std::string read(::Prompt::readline(prompt()));
            for(auto it = read.begin(); it != read.end(); it++)
                d_deque.push_back(*it);
            d_deque.push_back('\n');
            d_deque.push_back(AT_EOF);
        } else {
            // get char from stream
            ch = d_in->get();
            return *d_in ? ch : AT_EOF;
        }
    }

    ch = d_deque.front();
    d_deque.pop_front();

    return ch;
}

std::string KismetScannerBase::Input::prompt() {
    std::stringstream ss;
    ss << d_lineNr << "> ";
    return ss.str();
}

void KismetScannerBase::Input::reRead(size_t ch) {
    if(ch < 0x100) {
        if(ch == '\n')
            --d_lineNr;
        d_deque.push_front(ch);
    }
}

void KismetScannerBase::Input::reRead(std::string const &str, size_t fm) {
    for (size_t idx = str.size(); idx-- > fm; )
        reRead(str[idx]);
}

size_t KismetScannerBase::Input::lineNr() const {
    return d_lineNr;
}

void KismetScannerBase::Input::close() {
    // Force closing the stream
    delete d_in;
    // switchStreams also closes
    d_in = 0;
}

